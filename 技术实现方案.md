# 推特与Solana监控机器人 - 技术实现方案

## 项目概览
- **项目名称**: 推特与Solana监控机器人
- **开发语言**: Python 3.9+
- **主要框架**: FastAPI, SQLAlchemy, APScheduler
- **数据库**: PostgreSQL
- **部署方式**: Docker容器化部署

## 技术架构设计

### 1. 系统架构图
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Twitter API   │    │   Solana RPC    │    │   微信企业API    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         └───────────────────────┼───────────────────────┘
                                 │
    ┌─────────────────────────────────────────────────────────┐
    │                   API Gateway                           │
    │              (FastAPI Application)                      │
    └─────────────────────────────────────────────────────────┘
                                 │
    ┌─────────────────────────────────────────────────────────┐
    │                  Service Layer                          │
    │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐       │
    │  │Twitter      │ │Solana       │ │Notification │       │
    │  │Monitor      │ │Monitor      │ │Service      │       │
    │  │Service      │ │Service      │ │             │       │
    │  └─────────────┘ └─────────────┘ └─────────────┘       │
    └─────────────────────────────────────────────────────────┘
                                 │
    ┌─────────────────────────────────────────────────────────┐
    │               Background Scheduler                      │
    │                 (APScheduler)                           │
    └─────────────────────────────────────────────────────────┘
                                 │
    ┌─────────────────────────────────────────────────────────┐
    │                 Data Layer                              │
    │                ┌─────────────┐                         │
    │                │PostgreSQL   │                         │
    │                │(主数据库)    │                         │
    │                └─────────────┘                         │
    └─────────────────────────────────────────────────────────┘
```

### 2. 核心技术栈

#### 后端框架
- **FastAPI**: 高性能异步Web框架，提供自动API文档
- **SQLAlchemy**: ORM框架，数据库操作
- **Alembic**: 数据库版本管理
- **APScheduler**: Python定时任务调度器
- **PostgreSQL**: 主数据库

#### 外部API集成
- **Twitter API v2**: 推特数据获取
- **Solana Web3.js**: Solana区块链交互
- **企业微信API**: 消息推送
- **CoinGecko API**: 代币价格数据

#### 监控和日志
- **Prometheus**: 系统监控指标
- **Grafana**: 监控面板
- **Loguru**: 结构化日志
- **Sentry**: 错误追踪

## 详细实现步骤

### 阶段1: 项目基础搭建 (1-2天)

#### 1.1 环境配置
```bash
# 创建项目结构
monitor_bot/
├── src/
│   ├── api/
│   ├── services/
│   ├── models/
│   ├── utils/
│   └── config/
├── tests/
├── docker/
├── migrations/
├── requirements/
└── scripts/
```

#### 1.2 依赖安装
```python
# requirements/base.txt
fastapi==0.104.1
uvicorn[standard]==0.24.0
sqlalchemy==2.0.23
alembic==1.12.1
apscheduler==3.10.4
psycopg2-binary==2.9.9
requests==2.31.0
pydantic==2.5.0
python-multipart==0.0.6
loguru==0.7.2
solana==0.30.2
```

#### 1.3 配置管理
```python
# src/config/settings.py
from pydantic_settings import BaseSettings
from typing import List

class Settings(BaseSettings):
    # 数据库配置
    database_url: str = "postgresql://user:pass@localhost/monitor_bot"
    
    # API配置
    twitter_bearer_token: str
    solana_rpc_url: str = "https://api.mainnet-beta.solana.com"
    wechat_webhook_url: str
    
    # 监控配置
    twitter_check_interval: int = 60
    solana_check_interval: int = 30
    
    # 安全配置
    secret_key: str
    debug: bool = False
    
    class Config:
        env_file = ".env"
```

### 阶段2: 数据模型设计 (1天)

#### 2.1 数据库模型
```python
# src/models/base.py
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, DateTime, func

Base = declarative_base()

class TimestampMixin:
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

# src/models/twitter.py
class TwitterUser(Base, TimestampMixin):
    __tablename__ = "twitter_users"
    
    id = Column(Integer, primary_key=True)
    username = Column(String(100), unique=True, nullable=False)
    display_name = Column(String(200))
    twitter_id = Column(String(50), unique=True)
    followers_count = Column(Integer, default=0)
    min_followers = Column(Integer, default=10000)
    keywords = Column(Text)  # JSON格式存储关键词
    is_active = Column(Boolean, default=True)

class Tweet(Base, TimestampMixin):
    __tablename__ = "tweets"
    
    id = Column(Integer, primary_key=True)
    tweet_id = Column(String(50), unique=True, nullable=False)
    user_id = Column(Integer, ForeignKey("twitter_users.id"))
    content = Column(Text, nullable=False)
    ca_addresses = Column(Text)  # JSON格式存储检测到的CA地址
    is_processed = Column(Boolean, default=False)
    is_notified = Column(Boolean, default=False)
    tweet_url = Column(String(500))

# src/models/solana.py
class SolanaWallet(Base, TimestampMixin):
    __tablename__ = "solana_wallets"
    
    id = Column(Integer, primary_key=True)
    address = Column(String(44), unique=True, nullable=False)
    alias = Column(String(100))
    min_amount_usd = Column(Numeric(10, 2), default=1000.00)
    watch_tokens = Column(Text)  # JSON格式存储监控的代币列表
    is_active = Column(Boolean, default=True)

class SolanaTransaction(Base, TimestampMixin):
    __tablename__ = "solana_transactions"
    
    id = Column(Integer, primary_key=True)
    signature = Column(String(100), unique=True, nullable=False)
    wallet_id = Column(Integer, ForeignKey("solana_wallets.id"))
    transaction_type = Column(String(50))  # buy, sell, transfer, etc.
    token_address = Column(String(44))
    token_symbol = Column(String(20))
    amount = Column(Numeric(20, 8))
    amount_usd = Column(Numeric(10, 2))
    is_processed = Column(Boolean, default=False)
    is_notified = Column(Boolean, default=False)
    block_time = Column(DateTime(timezone=True))
    solscan_url = Column(String(500))
```

### 阶段3: 推特监控服务 (2-3天)

#### 3.1 推特API客户端
```python
# src/services/twitter_client.py
import requests
import re
from typing import List, Dict, Optional

class TwitterClient:
    def __init__(self, bearer_token: str):
        self.bearer_token = bearer_token
        self.base_url = "https://api.twitter.com/2"
        
    def _headers(self) -> Dict[str, str]:
        return {
            "Authorization": f"Bearer {self.bearer_token}",
            "Content-Type": "application/json"
        }
    
    def get_user_by_username(self, username: str) -> Optional[Dict]:
        """根据用户名获取用户信息"""
        url = f"{self.base_url}/users/by/username/{username}"
        params = {
            "user.fields": "id,name,username,public_metrics,verified"
        }
        
        response = requests.get(url, headers=self._headers(), params=params)
        if response.status_code == 200:
            return response.json().get("data")
        return None
    
    def get_user_tweets(self, user_id: str, since_id: Optional[str] = None) -> List[Dict]:
        """获取用户的最新推文"""
        url = f"{self.base_url}/users/{user_id}/tweets"
        params = {
            "tweet.fields": "id,text,created_at,public_metrics,context_annotations",
            "max_results": 10,
            "exclude": "retweets,replies"
        }
        
        if since_id:
            params["since_id"] = since_id
            
        response = requests.get(url, headers=self._headers(), params=params)
        if response.status_code == 200:
            return response.json().get("data", [])
        return []

# src/services/twitter_analyzer.py
class TwitterAnalyzer:
    
    CA_PATTERNS = [
        r'CA[:\s]*([A-Za-z0-9]{32,44})',
        r'合约地址[:\s]*([A-Za-z0-9]{32,44})',
        r'Contract[:\s]*([A-Za-z0-9]{32,44})',
        r'Token[:\s]*([A-Za-z0-9]{32,44})',
    ]
    
    EXCLUDE_KEYWORDS = ['test', 'fake', '测试', '假币', 'scam']
    
    def extract_ca_addresses(self, text: str) -> List[str]:
        """提取推文中的CA地址"""
        ca_addresses = []
        
        for pattern in self.CA_PATTERNS:
            matches = re.findall(pattern, text, re.IGNORECASE)
            for match in matches:
                if self._is_valid_ca(match) and not self._contains_exclude_keywords(text):
                    ca_addresses.append(match)
        
        return list(set(ca_addresses))  # 去重
    
    def _is_valid_ca(self, address: str) -> bool:
        """验证CA地址格式"""
        return len(address) >= 32 and len(address) <= 44 and address.isalnum()
    
    def _contains_exclude_keywords(self, text: str) -> bool:
        """检查是否包含排除关键词"""
        text_lower = text.lower()
        return any(keyword in text_lower for keyword in self.EXCLUDE_KEYWORDS)
    
    def check_keywords_match(self, text: str, keywords: List[str]) -> bool:
        """检查推文是否匹配关键词"""
        if not keywords:
            return True
            
        text_lower = text.lower()
        return any(keyword.lower() in text_lower for keyword in keywords)
```

#### 3.2 推特监控任务
```python
# src/tasks/twitter_tasks.py
from apscheduler.schedulers.background import BackgroundScheduler
from src.services.twitter_client import TwitterClient
from src.services.twitter_analyzer import TwitterAnalyzer
from src.models.twitter import TwitterUser, Tweet
from src.services.notification_service import NotificationService
from loguru import logger
import json

def check_twitter_updates():
    """检查推特更新的主任务"""
    twitter_client = TwitterClient(settings.twitter_bearer_token)
    analyzer = TwitterAnalyzer()
    notification_service = NotificationService()
    
    # 获取所有活跃的推特用户
    active_users = session.query(TwitterUser).filter(
        TwitterUser.is_active == True
    ).all()
    
    for user in active_users:
        try:
            # 获取最新推文ID
            last_tweet = session.query(Tweet).filter(
                Tweet.user_id == user.id
            ).order_by(Tweet.created_at.desc()).first()
            
            since_id = last_tweet.tweet_id if last_tweet else None
            
            # 获取新推文
            tweets = twitter_client.get_user_tweets(user.twitter_id, since_id)
            
            for tweet_data in tweets:
                # 检查关键词匹配
                keywords = json.loads(user.keywords) if user.keywords else []
                if not analyzer.check_keywords_match(tweet_data['text'], keywords):
                    continue
                
                # 提取CA地址
                ca_addresses = analyzer.extract_ca_addresses(tweet_data['text'])
                
                # 保存推文
                tweet = Tweet(
                    tweet_id=tweet_data['id'],
                    user_id=user.id,
                    content=tweet_data['text'],
                    ca_addresses=json.dumps(ca_addresses) if ca_addresses else None,
                    tweet_url=f"https://twitter.com/{user.username}/status/{tweet_data['id']}"
                )
                session.add(tweet)
                session.commit()
                
                # 如果检测到CA地址，发送通知
                if ca_addresses:
                    notification_service.send_twitter_notification(user, tweet, ca_addresses)
                    tweet.is_notified = True
                    session.commit()
                    
        except Exception as e:
            logger.error(f"Error checking tweets for user {user.username}: {e}")
```

### 阶段4: Solana监控服务 (3-4天)

#### 4.1 Solana客户端
```python
# src/services/solana_client.py
from solana.rpc.api import Client
from solana.publickey import PublicKey
import requests
from typing import List, Dict, Optional

class SolanaClient:
    def __init__(self, rpc_url: str):
        self.client = Client(rpc_url)
        self.rpc_url = rpc_url
    
    def get_wallet_transactions(self, wallet_address: str, before: Optional[str] = None) -> List[Dict]:
        """获取钱包交易记录"""
        pubkey = PublicKey(wallet_address)
        
        # 获取签名列表
        signatures_response = self.client.get_signatures_for_address(
            pubkey,
            before=before,
            limit=10
        )
        
        transactions = []
        for sig_info in signatures_response['result']:
            if sig_info['err']:  # 跳过失败的交易
                continue
                
            # 获取交易详情
            tx_response = self.client.get_transaction(
                sig_info['signature'],
                encoding='jsonParsed'
            )
            
            if tx_response['result']:
                transactions.append({
                    'signature': sig_info['signature'],
                    'slot': sig_info['slot'],
                    'blockTime': sig_info['blockTime'],
                    'transaction': tx_response['result']
                })
        
        return transactions
    
    def get_token_info(self, mint_address: str) -> Optional[Dict]:
        """获取代币信息"""
        try:
            # 从Jupiter API获取代币信息
            response = requests.get(f"https://token.jup.ag/strict/{mint_address}")
            if response.status_code == 200:
                return response.json()
        except:
            pass
        
        return None
    
    def get_token_price(self, mint_address: str) -> Optional[float]:
        """获取代币价格"""
        try:
            response = requests.get(
                f"https://price.jup.ag/v4/price?ids={mint_address}"
            )
            if response.status_code == 200:
                data = response.json()
                return data['data'][mint_address]['price']
        except:
            pass
        
        return None

# src/services/solana_analyzer.py
class SolanaAnalyzer:
    
    def __init__(self):
        self.solana_client = SolanaClient(settings.solana_rpc_url)
    
    def parse_transaction(self, tx_data: Dict) -> Optional[Dict]:
        """解析交易数据"""
        transaction = tx_data['transaction']
        meta = transaction.get('meta', {})
        
        if not meta or meta.get('err'):
            return None
        
        # 解析指令
        instructions = transaction['transaction']['message']['instructions']
        
        for instruction in instructions:
            parsed = instruction.get('parsed', {})
            
            if parsed.get('type') in ['transfer', 'transferChecked']:
                return self._parse_token_transfer(parsed, tx_data)
            elif 'swap' in parsed.get('type', '').lower():
                return self._parse_swap(parsed, tx_data)
        
        return None
    
    def _parse_token_transfer(self, parsed: Dict, tx_data: Dict) -> Dict:
        """解析代币转账"""
        info = parsed['info']
        
        return {
            'type': 'transfer',
            'signature': tx_data['signature'],
            'blockTime': tx_data['blockTime'],
            'source': info.get('source', ''),
            'destination': info.get('destination', ''),
            'amount': info.get('amount', '0'),
            'mint': info.get('mint', ''),
            'authority': info.get('authority', '')
        }
    
    def _parse_swap(self, parsed: Dict, tx_data: Dict) -> Dict:
        """解析交换交易"""
        # 这里需要根据具体的DEX协议来解析
        # 例如：Raydium, Orca, Jupiter等
        return {
            'type': 'swap',
            'signature': tx_data['signature'],
            'blockTime': tx_data['blockTime'],
            # 其他字段根据具体协议解析
        }
```

#### 4.2 Solana监控任务
```python
# src/tasks/solana_tasks.py
def check_solana_wallets():
    """检查Solana钱包活动"""
    solana_client = SolanaClient(settings.solana_rpc_url)
    analyzer = SolanaAnalyzer()
    notification_service = NotificationService()
    
    # 获取所有活跃的钱包
    active_wallets = session.query(SolanaWallet).filter(
        SolanaWallet.is_active == True
    ).all()
    
    for wallet in active_wallets:
        try:
            # 获取最新交易签名
            last_tx = session.query(SolanaTransaction).filter(
                SolanaTransaction.wallet_id == wallet.id
            ).order_by(SolanaTransaction.created_at.desc()).first()
            
            before = last_tx.signature if last_tx else None
            
            # 获取新交易
            transactions = solana_client.get_wallet_transactions(wallet.address, before)
            
            for tx_data in transactions:
                # 解析交易
                parsed_tx = analyzer.parse_transaction(tx_data)
                if not parsed_tx:
                    continue
                
                # 获取代币价格
                token_price = None
                if parsed_tx.get('mint'):
                    token_price = solana_client.get_token_price(parsed_tx['mint'])
                
                # 计算USD价值
                amount_usd = None
                if token_price and parsed_tx.get('amount'):
                    amount_usd = float(parsed_tx['amount']) * token_price
                
                # 检查最小金额过滤
                if amount_usd and amount_usd < wallet.min_amount_usd:
                    continue
                
                # 保存交易
                transaction = SolanaTransaction(
                    signature=parsed_tx['signature'],
                    wallet_id=wallet.id,
                    transaction_type=parsed_tx['type'],
                    token_address=parsed_tx.get('mint', ''),
                    amount=parsed_tx.get('amount', '0'),
                    amount_usd=amount_usd,
                    block_time=datetime.fromtimestamp(parsed_tx['blockTime']),
                    solscan_url=f"https://solscan.io/tx/{parsed_tx['signature']}"
                )
                session.add(transaction)
                session.commit()
                
                # 发送通知
                if amount_usd and amount_usd >= wallet.min_amount_usd:
                    notification_service.send_solana_notification(wallet, transaction)
                    transaction.is_notified = True
                    session.commit()
                    
        except Exception as e:
            logger.error(f"Error checking wallet {wallet.alias}: {e}")
```

### 阶段5: 通知服务 (1-2天)

#### 5.1 企业微信通知
```python
# src/services/notification_service.py
import requests
from typing import List
from datetime import datetime

class NotificationService:
    
    def __init__(self):
        self.webhook_url = settings.wechat_webhook_url
    
    def send_twitter_notification(self, user: TwitterUser, tweet: Tweet, ca_addresses: List[str]):
        """发送推特通知"""
        ca_text = "\n".join([f"💎 **检测到CA**: `{ca}`" for ca in ca_addresses])
        
        message = f"""🐦 **推特监控提醒**

👤 **用户**: {user.display_name} (@{user.username})
🕐 **时间**: {tweet.created_at.strftime('%Y-%m-%d %H:%M:%S')}
📝 **内容**: {tweet.content[:200]}{'...' if len(tweet.content) > 200 else ''}

{ca_text}

🔗 [查看推文]({tweet.tweet_url})
👥 **粉丝数**: {user.followers_count:,}"""

        self._send_message(message)
    
    def send_solana_notification(self, wallet: SolanaWallet, transaction: SolanaTransaction):
        """发送Solana交易通知"""
        # 获取代币信息
        token_info = self._get_token_info(transaction.token_address)
        token_symbol = token_info.get('symbol', 'Unknown') if token_info else 'Unknown'
        
        message = f"""💰 **Solana交易监控**

👛 **钱包**: {wallet.alias}
📊 **操作**: {transaction.transaction_type.upper()}
🪙 **代币**: {token_symbol} ({transaction.token_address[:8]}...)
💵 **金额**: {transaction.amount:,.4f} {token_symbol}
💲 **价值**: ≈ ${transaction.amount_usd:,.2f}
⏰ **时间**: {transaction.block_time.strftime('%Y-%m-%d %H:%M:%S')}

🔗 [查看交易]({transaction.solscan_url})"""

        self._send_message(message)
    
    def _send_message(self, message: str):
        """发送企业微信消息"""
        payload = {
            "msgtype": "markdown",
            "markdown": {
                "content": message
            }
        }
        
        try:
            response = requests.post(self.webhook_url, json=payload)
            if response.status_code == 200:
                logger.info("Notification sent successfully")
            else:
                logger.error(f"Failed to send notification: {response.text}")
        except Exception as e:
            logger.error(f"Error sending notification: {e}")
    
    def _get_token_info(self, mint_address: str) -> dict:
        """获取代币信息"""
        # 从Solana客户端获取
        solana_client = SolanaClient(settings.solana_rpc_url)
        token_info = solana_client.get_token_info(mint_address) or {}
        
        return token_info
```

### 阶段6: API接口开发 (2天)

#### 6.1 REST API
```python
# src/api/main.py
from fastapi import FastAPI, Depends, HTTPException
from src.api.routers import twitter, solana, notifications

app = FastAPI(
    title="Monitor Bot API",
    description="推特与Solana监控机器人API",
    version="1.0.0"
)

app.include_router(twitter.router, prefix="/api/twitter", tags=["Twitter"])
app.include_router(solana.router, prefix="/api/solana", tags=["Solana"])
app.include_router(notifications.router, prefix="/api/notifications", tags=["Notifications"])

# src/api/routers/twitter.py
from fastapi import APIRouter, Depends
from src.schemas.twitter import TwitterUserCreate, TwitterUserResponse
from src.services.twitter_service import TwitterService

router = APIRouter()

@router.get("/users", response_model=List[TwitterUserResponse])
async def get_twitter_users(service: TwitterService = Depends()):
    """获取所有推特用户"""
    return service.get_all_users()

@router.post("/users", response_model=TwitterUserResponse)
async def create_twitter_user(
    user_data: TwitterUserCreate, 
    service: TwitterService = Depends()
):
    """添加新的推特用户"""
    return service.create_user(user_data)

@router.get("/users/{user_id}/tweets")
async def get_user_tweets(user_id: int, service: TwitterService = Depends()):
    """获取用户的推文"""
    return service.get_user_tweets(user_id)

@router.post("/users/{user_id}/check")
async def trigger_user_check(user_id: int, service: TwitterService = Depends()):
    """手动触发用户检查"""
    return service.trigger_check(user_id)
```

#### 6.2 数据模式定义
```python
# src/schemas/twitter.py
from pydantic import BaseModel
from typing import List, Optional
from datetime import datetime

class TwitterUserBase(BaseModel):
    username: str
    display_name: str
    min_followers: int = 10000
    keywords: List[str] = []
    is_active: bool = True

class TwitterUserCreate(TwitterUserBase):
    pass

class TwitterUserResponse(TwitterUserBase):
    id: int
    twitter_id: str
    followers_count: int
    created_at: datetime
    updated_at: Optional[datetime]
    
    class Config:
        from_attributes = True

class TweetResponse(BaseModel):
    id: int
    tweet_id: str
    content: str
    ca_addresses: List[str] = []
    tweet_url: str
    created_at: datetime
    is_processed: bool
    is_notified: bool
    
    class Config:
        from_attributes = True
```

### 阶段7: 部署配置 (1-2天)

#### 7.1 Docker配置
```dockerfile
# Dockerfile
FROM python:3.9-slim

WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    && rm -rf /var/lib/apt/lists/*

# 复制依赖文件
COPY requirements/ requirements/
RUN pip install -r requirements/production.txt

# 复制应用代码
COPY . .

# 设置环境变量
ENV PYTHONPATH=/app
ENV PYTHONUNBUFFERED=1

# 暴露端口
EXPOSE 8000

# 启动命令
CMD ["uvicorn", "src.api.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  web:
    build: .
    ports:
      - "8000:8000"
    depends_on:
      - db
    environment:
      - DATABASE_URL=postgresql://postgres:password@db:5432/monitor_bot
    volumes:
      - .:/app
    
  
  db:
    image: postgres:13
    environment:
      - POSTGRES_DB=monitor_bot
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
  
volumes:
  postgres_data:
```

#### 7.2 定时任务配置
```python
# src/scheduler/scheduler.py
from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.executors.pool import ThreadPoolExecutor
from src.tasks.twitter_tasks import check_twitter_updates
from src.tasks.solana_tasks import check_solana_wallets
from src.tasks.maintenance_tasks import cleanup_old_data
from loguru import logger

class TaskScheduler:
    def __init__(self):
        executors = {
            'default': ThreadPoolExecutor(20),
        }
        
        job_defaults = {
            'coalesce': False,
            'max_instances': 3
        }
        
        self.scheduler = BackgroundScheduler(
            executors=executors,
            job_defaults=job_defaults,
            timezone='Asia/Shanghai'
        )
    
    def start_scheduler(self):
        """启动定时任务"""
        # 推特监控 - 每分钟
        self.scheduler.add_job(
            check_twitter_updates,
            'interval',
            seconds=60,
            id='twitter_monitor',
            name='Twitter监控任务'
        )
        
        # Solana监控 - 每30秒
        self.scheduler.add_job(
            check_solana_wallets,
            'interval',
            seconds=30,
            id='solana_monitor',
            name='Solana监控任务'
        )
        
        # 数据清理 - 每天凌晨2点
        self.scheduler.add_job(
            cleanup_old_data,
            'cron',
            hour=2,
            minute=0,
            id='cleanup_data',
            name='数据清理任务'
        )
        
        self.scheduler.start()
        logger.info("定时任务调度器已启动")
    
    def shutdown(self):
        """关闭调度器"""
        self.scheduler.shutdown()
        logger.info("定时任务调度器已关闭")
```

### 阶段8: 监控和日志 (1天)

#### 8.1 系统监控
```python
# src/monitoring/metrics.py
from prometheus_client import Counter, Histogram, Gauge
import time

# 定义指标
TWITTER_CHECKS = Counter('twitter_checks_total', 'Total Twitter checks')
SOLANA_CHECKS = Counter('solana_checks_total', 'Total Solana checks')
NOTIFICATIONS_SENT = Counter('notifications_sent_total', 'Total notifications sent')
API_REQUESTS = Counter('api_requests_total', 'Total API requests', ['method', 'endpoint'])
RESPONSE_TIME = Histogram('response_time_seconds', 'Response time')
ACTIVE_CONNECTIONS = Gauge('active_connections', 'Active connections')

# 监控装饰器
def monitor_api_call(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        try:
            result = func(*args, **kwargs)
            RESPONSE_TIME.observe(time.time() - start_time)
            return result
        except Exception as e:
            # 记录错误
            raise e
    return wrapper
```

#### 8.2 结构化日志
```python
# src/utils/logger.py
from loguru import logger
import sys
from src.config.settings import settings

def setup_logging():
    # 移除默认handler
    logger.remove()
    
    # 控制台输出
    logger.add(
        sys.stdout,
        format="<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>",
        level="INFO" if not settings.debug else "DEBUG",
        colorize=True
    )
    
    # 文件输出
    logger.add(
        "logs/monitor_bot.log",
        format="{time:YYYY-MM-DD HH:mm:ss} | {level} | {name}:{function}:{line} - {message}",
        level="INFO",
        rotation="1 day",
        retention="30 days",
        compression="zip"
    )
    
    # 错误文件
    logger.add(
        "logs/error.log",
        format="{time:YYYY-MM-DD HH:mm:ss} | {level} | {name}:{function}:{line} - {message}",
        level="ERROR",
        rotation="1 day",
        retention="30 days"
    )

setup_logging()
```

## 项目时间规划

### 总体时间估算: 8-10个工作日

- **阶段1**: 项目基础搭建 (1天)
- **阶段2**: 数据模型设计 (1天)  
- **阶段3**: 推特监控服务 (2天)
- **阶段4**: Solana监控服务 (2-3天)
- **阶段5**: 通知服务 (1天)
- **阶段6**: API接口开发 (1天)
- **阶段7**: 部署配置 (1天)
- **阶段8**: 监控和日志 (半天)

### 里程碑节点

1. **第2天**: 完成基础架构和数据模型
2. **第4天**: 完成推特监控功能
3. **第7天**: 完成Solana监控功能  
4. **第8天**: 完成API和通知功能
5. **第10天**: 完成部署和监控配置

## 风险评估与应对

### 主要风险

1. **API限制风险**
   - Twitter API有频率限制
   - 应对: 实现请求缓存和错误重试

2. **区块链数据解析复杂**
   - Solana交易结构复杂
   - 应对: 分阶段实现，先支持常见交易类型

3. **实时性要求高**
   - 需要低延迟监控
   - 应对: 使用WebSocket和异步处理

4. **数据量增长**
   - 历史数据可能很大
   - 应对: 实现数据分区和清理策略

### 技术难点

1. **交易解析准确性**: 需要深入理解Solana交易结构
2. **通知去重**: 避免重复通知相同内容
3. **系统稳定性**: 确保7x24小时稳定运行
4. **扩展性**: 支持添加新的监控目标和通知渠道

## 后续优化方向

1. **机器学习增强**: 使用ML模型提高CA地址识别准确率
2. **多链支持**: 扩展到以太坊、BSC等其他区块链
3. **智能分析**: 添加交易模式分析和异常检测
4. **Web界面**: 开发管理后台界面
5. **移动端**: 开发移动App推送
6. **数据可视化**: 添加图表和统计分析