# æ¨ç‰¹ä¸Solanaç›‘æ§æœºå™¨äºº - æŠ€æœ¯å®ç°æ–¹æ¡ˆ

## é¡¹ç›®æ¦‚è§ˆ
- **é¡¹ç›®åç§°**: æ¨ç‰¹ä¸Solanaç›‘æ§æœºå™¨äºº
- **å¼€å‘è¯­è¨€**: Python 3.9+
- **ä¸»è¦æ¡†æ¶**: FastAPI, SQLAlchemy, APScheduler
- **æ•°æ®åº“**: PostgreSQL
- **éƒ¨ç½²æ–¹å¼**: Dockerå®¹å™¨åŒ–éƒ¨ç½²

## æŠ€æœ¯æ¶æ„è®¾è®¡

### 1. ç³»ç»Ÿæ¶æ„å›¾
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Twitter API   â”‚    â”‚   Solana RPC    â”‚    â”‚   å¾®ä¿¡ä¼ä¸šAPI    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                       â”‚                       â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                   API Gateway                           â”‚
    â”‚              (FastAPI Application)                      â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                  Service Layer                          â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
    â”‚  â”‚Twitter      â”‚ â”‚Solana       â”‚ â”‚Notification â”‚       â”‚
    â”‚  â”‚Monitor      â”‚ â”‚Monitor      â”‚ â”‚Service      â”‚       â”‚
    â”‚  â”‚Service      â”‚ â”‚Service      â”‚ â”‚             â”‚       â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚               Background Scheduler                      â”‚
    â”‚                 (APScheduler)                           â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                 Data Layer                              â”‚
    â”‚                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”‚
    â”‚                â”‚PostgreSQL   â”‚                         â”‚
    â”‚                â”‚(ä¸»æ•°æ®åº“)    â”‚                         â”‚
    â”‚                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. æ ¸å¿ƒæŠ€æœ¯æ ˆ

#### åç«¯æ¡†æ¶
- **FastAPI**: é«˜æ€§èƒ½å¼‚æ­¥Webæ¡†æ¶ï¼Œæä¾›è‡ªåŠ¨APIæ–‡æ¡£
- **SQLAlchemy**: ORMæ¡†æ¶ï¼Œæ•°æ®åº“æ“ä½œ
- **Alembic**: æ•°æ®åº“ç‰ˆæœ¬ç®¡ç†
- **APScheduler**: Pythonå®šæ—¶ä»»åŠ¡è°ƒåº¦å™¨
- **PostgreSQL**: ä¸»æ•°æ®åº“

#### å¤–éƒ¨APIé›†æˆ
- **Twitter API v2**: æ¨ç‰¹æ•°æ®è·å–
- **Solana Web3.js**: SolanaåŒºå—é“¾äº¤äº’
- **ä¼ä¸šå¾®ä¿¡API**: æ¶ˆæ¯æ¨é€
- **CoinGecko API**: ä»£å¸ä»·æ ¼æ•°æ®

#### ç›‘æ§å’Œæ—¥å¿—
- **Prometheus**: ç³»ç»Ÿç›‘æ§æŒ‡æ ‡
- **Grafana**: ç›‘æ§é¢æ¿
- **Loguru**: ç»“æ„åŒ–æ—¥å¿—
- **Sentry**: é”™è¯¯è¿½è¸ª

## è¯¦ç»†å®ç°æ­¥éª¤

### é˜¶æ®µ1: é¡¹ç›®åŸºç¡€æ­å»º (1-2å¤©)

#### 1.1 ç¯å¢ƒé…ç½®
```bash
# åˆ›å»ºé¡¹ç›®ç»“æ„
monitor_bot/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ api/
â”‚   â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ utils/
â”‚   â””â”€â”€ config/
â”œâ”€â”€ tests/
â”œâ”€â”€ docker/
â”œâ”€â”€ migrations/
â”œâ”€â”€ requirements/
â””â”€â”€ scripts/
```

#### 1.2 ä¾èµ–å®‰è£…
```python
# requirements/base.txt
fastapi==0.104.1
uvicorn[standard]==0.24.0
sqlalchemy==2.0.23
alembic==1.12.1
apscheduler==3.10.4
psycopg2-binary==2.9.9
requests==2.31.0
pydantic==2.5.0
python-multipart==0.0.6
loguru==0.7.2
solana==0.30.2
```

#### 1.3 é…ç½®ç®¡ç†
```python
# src/config/settings.py
from pydantic_settings import BaseSettings
from typing import List

class Settings(BaseSettings):
    # æ•°æ®åº“é…ç½®
    database_url: str = "postgresql://user:pass@localhost/monitor_bot"
    
    # APIé…ç½®
    twitter_bearer_token: str
    solana_rpc_url: str = "https://api.mainnet-beta.solana.com"
    wechat_webhook_url: str
    
    # ç›‘æ§é…ç½®
    twitter_check_interval: int = 60
    solana_check_interval: int = 30
    
    # å®‰å…¨é…ç½®
    secret_key: str
    debug: bool = False
    
    class Config:
        env_file = ".env"
```

### é˜¶æ®µ2: æ•°æ®æ¨¡å‹è®¾è®¡ (1å¤©)

#### 2.1 æ•°æ®åº“æ¨¡å‹
```python
# src/models/base.py
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy import Column, Integer, DateTime, func

Base = declarative_base()

class TimestampMixin:
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

# src/models/twitter.py
class TwitterUser(Base, TimestampMixin):
    __tablename__ = "twitter_users"
    
    id = Column(Integer, primary_key=True)
    username = Column(String(100), unique=True, nullable=False)
    display_name = Column(String(200))
    twitter_id = Column(String(50), unique=True)
    followers_count = Column(Integer, default=0)
    min_followers = Column(Integer, default=10000)
    keywords = Column(Text)  # JSONæ ¼å¼å­˜å‚¨å…³é”®è¯
    is_active = Column(Boolean, default=True)

class Tweet(Base, TimestampMixin):
    __tablename__ = "tweets"
    
    id = Column(Integer, primary_key=True)
    tweet_id = Column(String(50), unique=True, nullable=False)
    user_id = Column(Integer, ForeignKey("twitter_users.id"))
    content = Column(Text, nullable=False)
    ca_addresses = Column(Text)  # JSONæ ¼å¼å­˜å‚¨æ£€æµ‹åˆ°çš„CAåœ°å€
    is_processed = Column(Boolean, default=False)
    is_notified = Column(Boolean, default=False)
    tweet_url = Column(String(500))

# src/models/solana.py
class SolanaWallet(Base, TimestampMixin):
    __tablename__ = "solana_wallets"
    
    id = Column(Integer, primary_key=True)
    address = Column(String(44), unique=True, nullable=False)
    alias = Column(String(100))
    min_amount_usd = Column(Numeric(10, 2), default=1000.00)
    watch_tokens = Column(Text)  # JSONæ ¼å¼å­˜å‚¨ç›‘æ§çš„ä»£å¸åˆ—è¡¨
    is_active = Column(Boolean, default=True)

class SolanaTransaction(Base, TimestampMixin):
    __tablename__ = "solana_transactions"
    
    id = Column(Integer, primary_key=True)
    signature = Column(String(100), unique=True, nullable=False)
    wallet_id = Column(Integer, ForeignKey("solana_wallets.id"))
    transaction_type = Column(String(50))  # buy, sell, transfer, etc.
    token_address = Column(String(44))
    token_symbol = Column(String(20))
    amount = Column(Numeric(20, 8))
    amount_usd = Column(Numeric(10, 2))
    is_processed = Column(Boolean, default=False)
    is_notified = Column(Boolean, default=False)
    block_time = Column(DateTime(timezone=True))
    solscan_url = Column(String(500))
```

### é˜¶æ®µ3: æ¨ç‰¹ç›‘æ§æœåŠ¡ (2-3å¤©)

#### 3.1 æ¨ç‰¹APIå®¢æˆ·ç«¯
```python
# src/services/twitter_client.py
import requests
import re
from typing import List, Dict, Optional

class TwitterClient:
    def __init__(self, bearer_token: str):
        self.bearer_token = bearer_token
        self.base_url = "https://api.twitter.com/2"
        
    def _headers(self) -> Dict[str, str]:
        return {
            "Authorization": f"Bearer {self.bearer_token}",
            "Content-Type": "application/json"
        }
    
    def get_user_by_username(self, username: str) -> Optional[Dict]:
        """æ ¹æ®ç”¨æˆ·åè·å–ç”¨æˆ·ä¿¡æ¯"""
        url = f"{self.base_url}/users/by/username/{username}"
        params = {
            "user.fields": "id,name,username,public_metrics,verified"
        }
        
        response = requests.get(url, headers=self._headers(), params=params)
        if response.status_code == 200:
            return response.json().get("data")
        return None
    
    def get_user_tweets(self, user_id: str, since_id: Optional[str] = None) -> List[Dict]:
        """è·å–ç”¨æˆ·çš„æœ€æ–°æ¨æ–‡"""
        url = f"{self.base_url}/users/{user_id}/tweets"
        params = {
            "tweet.fields": "id,text,created_at,public_metrics,context_annotations",
            "max_results": 10,
            "exclude": "retweets,replies"
        }
        
        if since_id:
            params["since_id"] = since_id
            
        response = requests.get(url, headers=self._headers(), params=params)
        if response.status_code == 200:
            return response.json().get("data", [])
        return []

# src/services/twitter_analyzer.py
class TwitterAnalyzer:
    
    CA_PATTERNS = [
        r'CA[:\s]*([A-Za-z0-9]{32,44})',
        r'åˆçº¦åœ°å€[:\s]*([A-Za-z0-9]{32,44})',
        r'Contract[:\s]*([A-Za-z0-9]{32,44})',
        r'Token[:\s]*([A-Za-z0-9]{32,44})',
    ]
    
    EXCLUDE_KEYWORDS = ['test', 'fake', 'æµ‹è¯•', 'å‡å¸', 'scam']
    
    def extract_ca_addresses(self, text: str) -> List[str]:
        """æå–æ¨æ–‡ä¸­çš„CAåœ°å€"""
        ca_addresses = []
        
        for pattern in self.CA_PATTERNS:
            matches = re.findall(pattern, text, re.IGNORECASE)
            for match in matches:
                if self._is_valid_ca(match) and not self._contains_exclude_keywords(text):
                    ca_addresses.append(match)
        
        return list(set(ca_addresses))  # å»é‡
    
    def _is_valid_ca(self, address: str) -> bool:
        """éªŒè¯CAåœ°å€æ ¼å¼"""
        return len(address) >= 32 and len(address) <= 44 and address.isalnum()
    
    def _contains_exclude_keywords(self, text: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦åŒ…å«æ’é™¤å…³é”®è¯"""
        text_lower = text.lower()
        return any(keyword in text_lower for keyword in self.EXCLUDE_KEYWORDS)
    
    def check_keywords_match(self, text: str, keywords: List[str]) -> bool:
        """æ£€æŸ¥æ¨æ–‡æ˜¯å¦åŒ¹é…å…³é”®è¯"""
        if not keywords:
            return True
            
        text_lower = text.lower()
        return any(keyword.lower() in text_lower for keyword in keywords)
```

#### 3.2 æ¨ç‰¹ç›‘æ§ä»»åŠ¡
```python
# src/tasks/twitter_tasks.py
from apscheduler.schedulers.background import BackgroundScheduler
from src.services.twitter_client import TwitterClient
from src.services.twitter_analyzer import TwitterAnalyzer
from src.models.twitter import TwitterUser, Tweet
from src.services.notification_service import NotificationService
from loguru import logger
import json

def check_twitter_updates():
    """æ£€æŸ¥æ¨ç‰¹æ›´æ–°çš„ä¸»ä»»åŠ¡"""
    twitter_client = TwitterClient(settings.twitter_bearer_token)
    analyzer = TwitterAnalyzer()
    notification_service = NotificationService()
    
    # è·å–æ‰€æœ‰æ´»è·ƒçš„æ¨ç‰¹ç”¨æˆ·
    active_users = session.query(TwitterUser).filter(
        TwitterUser.is_active == True
    ).all()
    
    for user in active_users:
        try:
            # è·å–æœ€æ–°æ¨æ–‡ID
            last_tweet = session.query(Tweet).filter(
                Tweet.user_id == user.id
            ).order_by(Tweet.created_at.desc()).first()
            
            since_id = last_tweet.tweet_id if last_tweet else None
            
            # è·å–æ–°æ¨æ–‡
            tweets = twitter_client.get_user_tweets(user.twitter_id, since_id)
            
            for tweet_data in tweets:
                # æ£€æŸ¥å…³é”®è¯åŒ¹é…
                keywords = json.loads(user.keywords) if user.keywords else []
                if not analyzer.check_keywords_match(tweet_data['text'], keywords):
                    continue
                
                # æå–CAåœ°å€
                ca_addresses = analyzer.extract_ca_addresses(tweet_data['text'])
                
                # ä¿å­˜æ¨æ–‡
                tweet = Tweet(
                    tweet_id=tweet_data['id'],
                    user_id=user.id,
                    content=tweet_data['text'],
                    ca_addresses=json.dumps(ca_addresses) if ca_addresses else None,
                    tweet_url=f"https://twitter.com/{user.username}/status/{tweet_data['id']}"
                )
                session.add(tweet)
                session.commit()
                
                # å¦‚æœæ£€æµ‹åˆ°CAåœ°å€ï¼Œå‘é€é€šçŸ¥
                if ca_addresses:
                    notification_service.send_twitter_notification(user, tweet, ca_addresses)
                    tweet.is_notified = True
                    session.commit()
                    
        except Exception as e:
            logger.error(f"Error checking tweets for user {user.username}: {e}")
```

### é˜¶æ®µ4: Solanaç›‘æ§æœåŠ¡ (3-4å¤©)

#### 4.1 Solanaå®¢æˆ·ç«¯
```python
# src/services/solana_client.py
from solana.rpc.api import Client
from solana.publickey import PublicKey
import requests
from typing import List, Dict, Optional

class SolanaClient:
    def __init__(self, rpc_url: str):
        self.client = Client(rpc_url)
        self.rpc_url = rpc_url
    
    def get_wallet_transactions(self, wallet_address: str, before: Optional[str] = None) -> List[Dict]:
        """è·å–é’±åŒ…äº¤æ˜“è®°å½•"""
        pubkey = PublicKey(wallet_address)
        
        # è·å–ç­¾ååˆ—è¡¨
        signatures_response = self.client.get_signatures_for_address(
            pubkey,
            before=before,
            limit=10
        )
        
        transactions = []
        for sig_info in signatures_response['result']:
            if sig_info['err']:  # è·³è¿‡å¤±è´¥çš„äº¤æ˜“
                continue
                
            # è·å–äº¤æ˜“è¯¦æƒ…
            tx_response = self.client.get_transaction(
                sig_info['signature'],
                encoding='jsonParsed'
            )
            
            if tx_response['result']:
                transactions.append({
                    'signature': sig_info['signature'],
                    'slot': sig_info['slot'],
                    'blockTime': sig_info['blockTime'],
                    'transaction': tx_response['result']
                })
        
        return transactions
    
    def get_token_info(self, mint_address: str) -> Optional[Dict]:
        """è·å–ä»£å¸ä¿¡æ¯"""
        try:
            # ä»Jupiter APIè·å–ä»£å¸ä¿¡æ¯
            response = requests.get(f"https://token.jup.ag/strict/{mint_address}")
            if response.status_code == 200:
                return response.json()
        except:
            pass
        
        return None
    
    def get_token_price(self, mint_address: str) -> Optional[float]:
        """è·å–ä»£å¸ä»·æ ¼"""
        try:
            response = requests.get(
                f"https://price.jup.ag/v4/price?ids={mint_address}"
            )
            if response.status_code == 200:
                data = response.json()
                return data['data'][mint_address]['price']
        except:
            pass
        
        return None

# src/services/solana_analyzer.py
class SolanaAnalyzer:
    
    def __init__(self):
        self.solana_client = SolanaClient(settings.solana_rpc_url)
    
    def parse_transaction(self, tx_data: Dict) -> Optional[Dict]:
        """è§£æäº¤æ˜“æ•°æ®"""
        transaction = tx_data['transaction']
        meta = transaction.get('meta', {})
        
        if not meta or meta.get('err'):
            return None
        
        # è§£ææŒ‡ä»¤
        instructions = transaction['transaction']['message']['instructions']
        
        for instruction in instructions:
            parsed = instruction.get('parsed', {})
            
            if parsed.get('type') in ['transfer', 'transferChecked']:
                return self._parse_token_transfer(parsed, tx_data)
            elif 'swap' in parsed.get('type', '').lower():
                return self._parse_swap(parsed, tx_data)
        
        return None
    
    def _parse_token_transfer(self, parsed: Dict, tx_data: Dict) -> Dict:
        """è§£æä»£å¸è½¬è´¦"""
        info = parsed['info']
        
        return {
            'type': 'transfer',
            'signature': tx_data['signature'],
            'blockTime': tx_data['blockTime'],
            'source': info.get('source', ''),
            'destination': info.get('destination', ''),
            'amount': info.get('amount', '0'),
            'mint': info.get('mint', ''),
            'authority': info.get('authority', '')
        }
    
    def _parse_swap(self, parsed: Dict, tx_data: Dict) -> Dict:
        """è§£æäº¤æ¢äº¤æ˜“"""
        # è¿™é‡Œéœ€è¦æ ¹æ®å…·ä½“çš„DEXåè®®æ¥è§£æ
        # ä¾‹å¦‚ï¼šRaydium, Orca, Jupiterç­‰
        return {
            'type': 'swap',
            'signature': tx_data['signature'],
            'blockTime': tx_data['blockTime'],
            # å…¶ä»–å­—æ®µæ ¹æ®å…·ä½“åè®®è§£æ
        }
```

#### 4.2 Solanaç›‘æ§ä»»åŠ¡
```python
# src/tasks/solana_tasks.py
def check_solana_wallets():
    """æ£€æŸ¥Solanaé’±åŒ…æ´»åŠ¨"""
    solana_client = SolanaClient(settings.solana_rpc_url)
    analyzer = SolanaAnalyzer()
    notification_service = NotificationService()
    
    # è·å–æ‰€æœ‰æ´»è·ƒçš„é’±åŒ…
    active_wallets = session.query(SolanaWallet).filter(
        SolanaWallet.is_active == True
    ).all()
    
    for wallet in active_wallets:
        try:
            # è·å–æœ€æ–°äº¤æ˜“ç­¾å
            last_tx = session.query(SolanaTransaction).filter(
                SolanaTransaction.wallet_id == wallet.id
            ).order_by(SolanaTransaction.created_at.desc()).first()
            
            before = last_tx.signature if last_tx else None
            
            # è·å–æ–°äº¤æ˜“
            transactions = solana_client.get_wallet_transactions(wallet.address, before)
            
            for tx_data in transactions:
                # è§£æäº¤æ˜“
                parsed_tx = analyzer.parse_transaction(tx_data)
                if not parsed_tx:
                    continue
                
                # è·å–ä»£å¸ä»·æ ¼
                token_price = None
                if parsed_tx.get('mint'):
                    token_price = solana_client.get_token_price(parsed_tx['mint'])
                
                # è®¡ç®—USDä»·å€¼
                amount_usd = None
                if token_price and parsed_tx.get('amount'):
                    amount_usd = float(parsed_tx['amount']) * token_price
                
                # æ£€æŸ¥æœ€å°é‡‘é¢è¿‡æ»¤
                if amount_usd and amount_usd < wallet.min_amount_usd:
                    continue
                
                # ä¿å­˜äº¤æ˜“
                transaction = SolanaTransaction(
                    signature=parsed_tx['signature'],
                    wallet_id=wallet.id,
                    transaction_type=parsed_tx['type'],
                    token_address=parsed_tx.get('mint', ''),
                    amount=parsed_tx.get('amount', '0'),
                    amount_usd=amount_usd,
                    block_time=datetime.fromtimestamp(parsed_tx['blockTime']),
                    solscan_url=f"https://solscan.io/tx/{parsed_tx['signature']}"
                )
                session.add(transaction)
                session.commit()
                
                # å‘é€é€šçŸ¥
                if amount_usd and amount_usd >= wallet.min_amount_usd:
                    notification_service.send_solana_notification(wallet, transaction)
                    transaction.is_notified = True
                    session.commit()
                    
        except Exception as e:
            logger.error(f"Error checking wallet {wallet.alias}: {e}")
```

### é˜¶æ®µ5: é€šçŸ¥æœåŠ¡ (1-2å¤©)

#### 5.1 ä¼ä¸šå¾®ä¿¡é€šçŸ¥
```python
# src/services/notification_service.py
import requests
from typing import List
from datetime import datetime

class NotificationService:
    
    def __init__(self):
        self.webhook_url = settings.wechat_webhook_url
    
    def send_twitter_notification(self, user: TwitterUser, tweet: Tweet, ca_addresses: List[str]):
        """å‘é€æ¨ç‰¹é€šçŸ¥"""
        ca_text = "\n".join([f"ğŸ’ **æ£€æµ‹åˆ°CA**: `{ca}`" for ca in ca_addresses])
        
        message = f"""ğŸ¦ **æ¨ç‰¹ç›‘æ§æé†’**

ğŸ‘¤ **ç”¨æˆ·**: {user.display_name} (@{user.username})
ğŸ• **æ—¶é—´**: {tweet.created_at.strftime('%Y-%m-%d %H:%M:%S')}
ğŸ“ **å†…å®¹**: {tweet.content[:200]}{'...' if len(tweet.content) > 200 else ''}

{ca_text}

ğŸ”— [æŸ¥çœ‹æ¨æ–‡]({tweet.tweet_url})
ğŸ‘¥ **ç²‰ä¸æ•°**: {user.followers_count:,}"""

        self._send_message(message)
    
    def send_solana_notification(self, wallet: SolanaWallet, transaction: SolanaTransaction):
        """å‘é€Solanaäº¤æ˜“é€šçŸ¥"""
        # è·å–ä»£å¸ä¿¡æ¯
        token_info = self._get_token_info(transaction.token_address)
        token_symbol = token_info.get('symbol', 'Unknown') if token_info else 'Unknown'
        
        message = f"""ğŸ’° **Solanaäº¤æ˜“ç›‘æ§**

ğŸ‘› **é’±åŒ…**: {wallet.alias}
ğŸ“Š **æ“ä½œ**: {transaction.transaction_type.upper()}
ğŸª™ **ä»£å¸**: {token_symbol} ({transaction.token_address[:8]}...)
ğŸ’µ **é‡‘é¢**: {transaction.amount:,.4f} {token_symbol}
ğŸ’² **ä»·å€¼**: â‰ˆ ${transaction.amount_usd:,.2f}
â° **æ—¶é—´**: {transaction.block_time.strftime('%Y-%m-%d %H:%M:%S')}

ğŸ”— [æŸ¥çœ‹äº¤æ˜“]({transaction.solscan_url})"""

        self._send_message(message)
    
    def _send_message(self, message: str):
        """å‘é€ä¼ä¸šå¾®ä¿¡æ¶ˆæ¯"""
        payload = {
            "msgtype": "markdown",
            "markdown": {
                "content": message
            }
        }
        
        try:
            response = requests.post(self.webhook_url, json=payload)
            if response.status_code == 200:
                logger.info("Notification sent successfully")
            else:
                logger.error(f"Failed to send notification: {response.text}")
        except Exception as e:
            logger.error(f"Error sending notification: {e}")
    
    def _get_token_info(self, mint_address: str) -> dict:
        """è·å–ä»£å¸ä¿¡æ¯"""
        # ä»Solanaå®¢æˆ·ç«¯è·å–
        solana_client = SolanaClient(settings.solana_rpc_url)
        token_info = solana_client.get_token_info(mint_address) or {}
        
        return token_info
```

### é˜¶æ®µ6: APIæ¥å£å¼€å‘ (2å¤©)

#### 6.1 REST API
```python
# src/api/main.py
from fastapi import FastAPI, Depends, HTTPException
from src.api.routers import twitter, solana, notifications

app = FastAPI(
    title="Monitor Bot API",
    description="æ¨ç‰¹ä¸Solanaç›‘æ§æœºå™¨äººAPI",
    version="1.0.0"
)

app.include_router(twitter.router, prefix="/api/twitter", tags=["Twitter"])
app.include_router(solana.router, prefix="/api/solana", tags=["Solana"])
app.include_router(notifications.router, prefix="/api/notifications", tags=["Notifications"])

# src/api/routers/twitter.py
from fastapi import APIRouter, Depends
from src.schemas.twitter import TwitterUserCreate, TwitterUserResponse
from src.services.twitter_service import TwitterService

router = APIRouter()

@router.get("/users", response_model=List[TwitterUserResponse])
async def get_twitter_users(service: TwitterService = Depends()):
    """è·å–æ‰€æœ‰æ¨ç‰¹ç”¨æˆ·"""
    return service.get_all_users()

@router.post("/users", response_model=TwitterUserResponse)
async def create_twitter_user(
    user_data: TwitterUserCreate, 
    service: TwitterService = Depends()
):
    """æ·»åŠ æ–°çš„æ¨ç‰¹ç”¨æˆ·"""
    return service.create_user(user_data)

@router.get("/users/{user_id}/tweets")
async def get_user_tweets(user_id: int, service: TwitterService = Depends()):
    """è·å–ç”¨æˆ·çš„æ¨æ–‡"""
    return service.get_user_tweets(user_id)

@router.post("/users/{user_id}/check")
async def trigger_user_check(user_id: int, service: TwitterService = Depends()):
    """æ‰‹åŠ¨è§¦å‘ç”¨æˆ·æ£€æŸ¥"""
    return service.trigger_check(user_id)
```

#### 6.2 æ•°æ®æ¨¡å¼å®šä¹‰
```python
# src/schemas/twitter.py
from pydantic import BaseModel
from typing import List, Optional
from datetime import datetime

class TwitterUserBase(BaseModel):
    username: str
    display_name: str
    min_followers: int = 10000
    keywords: List[str] = []
    is_active: bool = True

class TwitterUserCreate(TwitterUserBase):
    pass

class TwitterUserResponse(TwitterUserBase):
    id: int
    twitter_id: str
    followers_count: int
    created_at: datetime
    updated_at: Optional[datetime]
    
    class Config:
        from_attributes = True

class TweetResponse(BaseModel):
    id: int
    tweet_id: str
    content: str
    ca_addresses: List[str] = []
    tweet_url: str
    created_at: datetime
    is_processed: bool
    is_notified: bool
    
    class Config:
        from_attributes = True
```

### é˜¶æ®µ7: éƒ¨ç½²é…ç½® (1-2å¤©)

#### 7.1 Dockeré…ç½®
```dockerfile
# Dockerfile
FROM python:3.9-slim

WORKDIR /app

# å®‰è£…ç³»ç»Ÿä¾èµ–
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    && rm -rf /var/lib/apt/lists/*

# å¤åˆ¶ä¾èµ–æ–‡ä»¶
COPY requirements/ requirements/
RUN pip install -r requirements/production.txt

# å¤åˆ¶åº”ç”¨ä»£ç 
COPY . .

# è®¾ç½®ç¯å¢ƒå˜é‡
ENV PYTHONPATH=/app
ENV PYTHONUNBUFFERED=1

# æš´éœ²ç«¯å£
EXPOSE 8000

# å¯åŠ¨å‘½ä»¤
CMD ["uvicorn", "src.api.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  web:
    build: .
    ports:
      - "8000:8000"
    depends_on:
      - db
    environment:
      - DATABASE_URL=postgresql://postgres:password@db:5432/monitor_bot
    volumes:
      - .:/app
    
  
  db:
    image: postgres:13
    environment:
      - POSTGRES_DB=monitor_bot
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
  
volumes:
  postgres_data:
```

#### 7.2 å®šæ—¶ä»»åŠ¡é…ç½®
```python
# src/scheduler/scheduler.py
from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.executors.pool import ThreadPoolExecutor
from src.tasks.twitter_tasks import check_twitter_updates
from src.tasks.solana_tasks import check_solana_wallets
from src.tasks.maintenance_tasks import cleanup_old_data
from loguru import logger

class TaskScheduler:
    def __init__(self):
        executors = {
            'default': ThreadPoolExecutor(20),
        }
        
        job_defaults = {
            'coalesce': False,
            'max_instances': 3
        }
        
        self.scheduler = BackgroundScheduler(
            executors=executors,
            job_defaults=job_defaults,
            timezone='Asia/Shanghai'
        )
    
    def start_scheduler(self):
        """å¯åŠ¨å®šæ—¶ä»»åŠ¡"""
        # æ¨ç‰¹ç›‘æ§ - æ¯åˆ†é’Ÿ
        self.scheduler.add_job(
            check_twitter_updates,
            'interval',
            seconds=60,
            id='twitter_monitor',
            name='Twitterç›‘æ§ä»»åŠ¡'
        )
        
        # Solanaç›‘æ§ - æ¯30ç§’
        self.scheduler.add_job(
            check_solana_wallets,
            'interval',
            seconds=30,
            id='solana_monitor',
            name='Solanaç›‘æ§ä»»åŠ¡'
        )
        
        # æ•°æ®æ¸…ç† - æ¯å¤©å‡Œæ™¨2ç‚¹
        self.scheduler.add_job(
            cleanup_old_data,
            'cron',
            hour=2,
            minute=0,
            id='cleanup_data',
            name='æ•°æ®æ¸…ç†ä»»åŠ¡'
        )
        
        self.scheduler.start()
        logger.info("å®šæ—¶ä»»åŠ¡è°ƒåº¦å™¨å·²å¯åŠ¨")
    
    def shutdown(self):
        """å…³é—­è°ƒåº¦å™¨"""
        self.scheduler.shutdown()
        logger.info("å®šæ—¶ä»»åŠ¡è°ƒåº¦å™¨å·²å…³é—­")
```

### é˜¶æ®µ8: ç›‘æ§å’Œæ—¥å¿— (1å¤©)

#### 8.1 ç³»ç»Ÿç›‘æ§
```python
# src/monitoring/metrics.py
from prometheus_client import Counter, Histogram, Gauge
import time

# å®šä¹‰æŒ‡æ ‡
TWITTER_CHECKS = Counter('twitter_checks_total', 'Total Twitter checks')
SOLANA_CHECKS = Counter('solana_checks_total', 'Total Solana checks')
NOTIFICATIONS_SENT = Counter('notifications_sent_total', 'Total notifications sent')
API_REQUESTS = Counter('api_requests_total', 'Total API requests', ['method', 'endpoint'])
RESPONSE_TIME = Histogram('response_time_seconds', 'Response time')
ACTIVE_CONNECTIONS = Gauge('active_connections', 'Active connections')

# ç›‘æ§è£…é¥°å™¨
def monitor_api_call(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        try:
            result = func(*args, **kwargs)
            RESPONSE_TIME.observe(time.time() - start_time)
            return result
        except Exception as e:
            # è®°å½•é”™è¯¯
            raise e
    return wrapper
```

#### 8.2 ç»“æ„åŒ–æ—¥å¿—
```python
# src/utils/logger.py
from loguru import logger
import sys
from src.config.settings import settings

def setup_logging():
    # ç§»é™¤é»˜è®¤handler
    logger.remove()
    
    # æ§åˆ¶å°è¾“å‡º
    logger.add(
        sys.stdout,
        format="<green>{time:YYYY-MM-DD HH:mm:ss}</green> | <level>{level}</level> | <cyan>{name}</cyan>:<cyan>{function}</cyan>:<cyan>{line}</cyan> - <level>{message}</level>",
        level="INFO" if not settings.debug else "DEBUG",
        colorize=True
    )
    
    # æ–‡ä»¶è¾“å‡º
    logger.add(
        "logs/monitor_bot.log",
        format="{time:YYYY-MM-DD HH:mm:ss} | {level} | {name}:{function}:{line} - {message}",
        level="INFO",
        rotation="1 day",
        retention="30 days",
        compression="zip"
    )
    
    # é”™è¯¯æ–‡ä»¶
    logger.add(
        "logs/error.log",
        format="{time:YYYY-MM-DD HH:mm:ss} | {level} | {name}:{function}:{line} - {message}",
        level="ERROR",
        rotation="1 day",
        retention="30 days"
    )

setup_logging()
```

## é¡¹ç›®æ—¶é—´è§„åˆ’

### æ€»ä½“æ—¶é—´ä¼°ç®—: 8-10ä¸ªå·¥ä½œæ—¥

- **é˜¶æ®µ1**: é¡¹ç›®åŸºç¡€æ­å»º (1å¤©)
- **é˜¶æ®µ2**: æ•°æ®æ¨¡å‹è®¾è®¡ (1å¤©)  
- **é˜¶æ®µ3**: æ¨ç‰¹ç›‘æ§æœåŠ¡ (2å¤©)
- **é˜¶æ®µ4**: Solanaç›‘æ§æœåŠ¡ (2-3å¤©)
- **é˜¶æ®µ5**: é€šçŸ¥æœåŠ¡ (1å¤©)
- **é˜¶æ®µ6**: APIæ¥å£å¼€å‘ (1å¤©)
- **é˜¶æ®µ7**: éƒ¨ç½²é…ç½® (1å¤©)
- **é˜¶æ®µ8**: ç›‘æ§å’Œæ—¥å¿— (åŠå¤©)

### é‡Œç¨‹ç¢‘èŠ‚ç‚¹

1. **ç¬¬2å¤©**: å®ŒæˆåŸºç¡€æ¶æ„å’Œæ•°æ®æ¨¡å‹
2. **ç¬¬4å¤©**: å®Œæˆæ¨ç‰¹ç›‘æ§åŠŸèƒ½
3. **ç¬¬7å¤©**: å®ŒæˆSolanaç›‘æ§åŠŸèƒ½  
4. **ç¬¬8å¤©**: å®ŒæˆAPIå’Œé€šçŸ¥åŠŸèƒ½
5. **ç¬¬10å¤©**: å®Œæˆéƒ¨ç½²å’Œç›‘æ§é…ç½®

## é£é™©è¯„ä¼°ä¸åº”å¯¹

### ä¸»è¦é£é™©

1. **APIé™åˆ¶é£é™©**
   - Twitter APIæœ‰é¢‘ç‡é™åˆ¶
   - åº”å¯¹: å®ç°è¯·æ±‚ç¼“å­˜å’Œé”™è¯¯é‡è¯•

2. **åŒºå—é“¾æ•°æ®è§£æå¤æ‚**
   - Solanaäº¤æ˜“ç»“æ„å¤æ‚
   - åº”å¯¹: åˆ†é˜¶æ®µå®ç°ï¼Œå…ˆæ”¯æŒå¸¸è§äº¤æ˜“ç±»å‹

3. **å®æ—¶æ€§è¦æ±‚é«˜**
   - éœ€è¦ä½å»¶è¿Ÿç›‘æ§
   - åº”å¯¹: ä½¿ç”¨WebSocketå’Œå¼‚æ­¥å¤„ç†

4. **æ•°æ®é‡å¢é•¿**
   - å†å²æ•°æ®å¯èƒ½å¾ˆå¤§
   - åº”å¯¹: å®ç°æ•°æ®åˆ†åŒºå’Œæ¸…ç†ç­–ç•¥

### æŠ€æœ¯éš¾ç‚¹

1. **äº¤æ˜“è§£æå‡†ç¡®æ€§**: éœ€è¦æ·±å…¥ç†è§£Solanaäº¤æ˜“ç»“æ„
2. **é€šçŸ¥å»é‡**: é¿å…é‡å¤é€šçŸ¥ç›¸åŒå†…å®¹
3. **ç³»ç»Ÿç¨³å®šæ€§**: ç¡®ä¿7x24å°æ—¶ç¨³å®šè¿è¡Œ
4. **æ‰©å±•æ€§**: æ”¯æŒæ·»åŠ æ–°çš„ç›‘æ§ç›®æ ‡å’Œé€šçŸ¥æ¸ é“

## åç»­ä¼˜åŒ–æ–¹å‘

1. **æœºå™¨å­¦ä¹ å¢å¼º**: ä½¿ç”¨MLæ¨¡å‹æé«˜CAåœ°å€è¯†åˆ«å‡†ç¡®ç‡
2. **å¤šé“¾æ”¯æŒ**: æ‰©å±•åˆ°ä»¥å¤ªåŠã€BSCç­‰å…¶ä»–åŒºå—é“¾
3. **æ™ºèƒ½åˆ†æ**: æ·»åŠ äº¤æ˜“æ¨¡å¼åˆ†æå’Œå¼‚å¸¸æ£€æµ‹
4. **Webç•Œé¢**: å¼€å‘ç®¡ç†åå°ç•Œé¢
5. **ç§»åŠ¨ç«¯**: å¼€å‘ç§»åŠ¨Appæ¨é€
6. **æ•°æ®å¯è§†åŒ–**: æ·»åŠ å›¾è¡¨å’Œç»Ÿè®¡åˆ†æ